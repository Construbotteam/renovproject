//ROS头文件
#include <ros/ros.h>
#include <std_msgs/String.h>
#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) \
                         && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif
#include "move_base_msgs/MoveBaseActionGoal.h"
#include "move_base_msgs/MoveBaseActionResult.h"
using namespace HalconCpp;



void action(float *position_row, float *position_col)
{
   // Local iconic variables
  HObject  ho_Image, ho_ImageChannel2, ho_Regions;
  HObject  ho_RegionObstacle, ho_RegionDilation, ho_RegionClosing;
  HObject  ho_RegionDifference, ho_BinImage, ho_BinImageObstacle;
  HObject  ho_RegionFillUp, ho_ImageReduced, ho_ConnectedRegions;
  HObject  ho_RegionCollection, ho_ObjectSelected, ho_ImageReduced2;
  HObject  ho_InitRegion, ho_Region, ho_RegionErosion, ho_Contours;
  HObject  ho_ContoursRegion, ho_RegionLines, ho_RegionUnion1;
  HObject  ho_Circle1, ho_RegionPoint, ho_RegionIntersection;
  HObject  ho_CurRegionLine, ho_RegionErosion1, ho_RegionPoint1;
  HObject  ho_RegionIntersection1, ho_RegionUnion, ho_Circle;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_Number, hv_count, hv_offset, hv_I, hv_Area, hv_CenterRow;
  HTuple  hv_CenterColumn, hv_Rows, hv_Columns, hv_flag, hv_index;
  HTuple  hv_LineRows, hv_LineColumns, hv_Grayval, hv_Sum;
  HTuple  hv_Length, hv_grayval, hv_position_row, hv_position_col;
  HTuple  hv_station_num, hv_AreaMax, hv_x, hv_y, hv_Row;
  HTuple  hv_Column, hv_i, hv_Rows1, hv_Columns1, hv_Indices;
  HTuple  hv_Area1, hv_Row1, hv_Column1, hv_Area3, hv_Row4;
  HTuple  hv_Column4, hv_x_max, hv_y_max, hv_Area2, hv_Row2;
  HTuple  hv_Column2;

//   dev_update_off();
  //Image Acquisition 01: Code generated by Image Acquisition 01
  ReadImage(&ho_Image, //'/home/hao/Documents/shen/halcon_pro/nav_sim/平面图/2.png'
      "/home/hao/Documents/shen/halcon_pro/nav_sim/\345\271\263\351\235\242\345\233\276/2.png");

  //********************************分离出房间*********************************
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width,hv_Height,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  AccessChannel(ho_Image, &ho_ImageChannel2, 2);
  //不带障碍物的region
  Threshold(ho_ImageChannel2, &ho_Regions, 0, 34);
  //带障碍物的region
  Threshold(ho_Image, &ho_RegionObstacle, 0, 80);
  DilationRectangle1(ho_Regions, &ho_RegionDilation, 5, 5);
  ClosingRectangle1(ho_RegionDilation, &ho_RegionClosing, 45, 45);
  //closing_rectangle1 (RegionDilation, RegionClosing, 10, 210)
  //识别出门的位置
  Difference(ho_RegionClosing, ho_RegionDilation, &ho_RegionDifference);
  RegionToBin(ho_RegionClosing, &ho_BinImage, 255, 0, hv_Width, hv_Height);
  //带障碍物的二值图
  RegionToBin(ho_RegionObstacle, &ho_BinImageObstacle, 255, 0, hv_Width, hv_Height);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  ReduceDomain(ho_BinImage, ho_RegionFillUp, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, 0, 80);
  Connection(ho_Regions, &ho_ConnectedRegions);
  //得到房间数量
  CountObj(ho_ConnectedRegions, &hv_Number);
  //stop ()

  //***************************************************************************
  //********************************对分离出的每个房间进行处理*******************************
  //计数
  hv_count = 0;
  hv_offset = 100;
  GenEmptyRegion(&ho_RegionCollection);
  {
  HTuple end_val36 = hv_Number;
  HTuple step_val36 = 1;
  for (hv_I=1; hv_I.Continue(end_val36, step_val36); hv_I += step_val36)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_I);
    ReduceDomain(ho_BinImageObstacle, ho_ObjectSelected, &ho_ImageReduced2);
    //搜索的区域
    Threshold(ho_ImageReduced2, &ho_InitRegion, 0, 80);
    //每次搜索后递减的区域变量
    Threshold(ho_ImageReduced2, &ho_Region, 0, 80);
    //确保产生的边缘region在BinImage内部
    ErosionRectangle1(ho_Region, &ho_RegionErosion, 3, 3);
    GenContourRegionXld(ho_RegionErosion, &ho_Contours, "border");
    GenRegionContourXld(ho_Contours, &ho_ContoursRegion, "margin");
    //dilation_rectangle1 (ContoursRegion, RegionDilation, 1, 1)
    //搜索的区域
    //fill_up (ContoursRegion, InitRegion)
    //每次搜索后递减的区域变量
    //fill_up (ContoursRegion, Region)

    AreaCenter(ho_Region, &hv_Area, &hv_CenterRow, &hv_CenterColumn);
    RegionToBin(ho_Region, &ho_BinImage, 0, 255, hv_Width, hv_Height);
    GetRegionPoints(ho_ContoursRegion, &hv_Rows, &hv_Columns);

    //0表示全都能扫到
    hv_flag = 0;
    {
    HTuple end_val59 = (hv_Rows.TupleLength())-1;
    HTuple step_val59 = 1;
    for (hv_index=0; hv_index.Continue(end_val59, step_val59); hv_index += step_val59)
    {
      GenRegionLine(&ho_RegionLines, HTuple(hv_Rows[hv_index]), HTuple(hv_Columns[hv_index]), 
          hv_CenterRow, hv_CenterColumn);
      GetRegionPoints(ho_RegionLines, &hv_LineRows, &hv_LineColumns);
      GetGrayval(ho_BinImage, hv_LineRows, hv_LineColumns, &hv_Grayval);
      TupleSum(hv_Grayval, &hv_Sum);
      if (0 != (int(hv_Sum>0)))
      {
        //1表示有地方扫不到
        hv_flag = 1;
        //显示扫不到的地方
        TupleLength(hv_LineRows, &hv_Length);
        hv_grayval = HTuple(hv_Length,128);
        //set_grayval (Image, LineRows, LineColumns, grayval)
      }
      //dev_display (BinImage)
      //dev_display (RegionLines)
      //stop ()
    }
    }
    //stop ()
    //如果直接给质心可以扫描完全，则结束算法
    if (0 != (int(hv_flag==0)))
    {
      hv_position_row[hv_count] = hv_CenterRow;
      hv_position_col[hv_count] = hv_CenterColumn;
      hv_count += 1;
      //************显示***************
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //dev_set_color ('green')
      //dev_display (RegionUnion1)
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      GenCircle(&ho_Circle1, hv_CenterRow, hv_CenterColumn, 2);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Circle1, HDevWindowStack::GetActive());
      //stop ()
      //******************************
      //如果直接给质心无法扫描完全，则执行后面的方案（贪婪）
    }
    else
    {

      hv_station_num = 0;
      while (0 != 1)
      {

        GenContourRegionXld(ho_RegionErosion, &ho_Contours, "border");
        GenRegionContourXld(ho_Contours, &ho_ContoursRegion, "margin");
        Union1(ho_ContoursRegion, &ho_ContoursRegion);
        //dilation_rectangle1 (ContoursRegion, RegionDilation, 1, 1)
        //fill_up (ContoursRegion, RegionFillUp)
        //erosion_rectangle1 (RegionFillUp, RegionFillUp, 4, 4)
        //reduce_domain (BinImageObstacle, Region, ImageReduced1)
        //threshold (ImageReduced1, Region, 0, 80)
        RegionToBin(ho_Region, &ho_BinImage, 0, 255, hv_Width, hv_Height);
        GetRegionPoints(ho_ContoursRegion, &hv_Rows, &hv_Columns);

        hv_AreaMax = 0;
        {
        HTuple end_val109 = hv_Height;
        HTuple step_val109 = 10;
        for (hv_x=0; hv_x.Continue(end_val109, step_val109); hv_x += step_val109)
        {
          {
          HTuple end_val110 = hv_Width;
          HTuple step_val110 = 10;
          for (hv_y=0; hv_y.Continue(end_val110, step_val110); hv_y += step_val110)
          {
            GenRegionPoints(&ho_RegionPoint, hv_x, hv_y);
            Intersection(ho_RegionPoint, ho_InitRegion, &ho_RegionIntersection);
            AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Column);
            if (0 != (int(hv_Area>0)))
            {
              GenEmptyRegion(&ho_RegionUnion1);
              {
              HTuple end_val116 = (hv_Rows.TupleLength())-1;
              HTuple step_val116 = 1;
              for (hv_i=0; hv_i.Continue(end_val116, step_val116); hv_i += step_val116)
              {
                GenRegionLine(&ho_CurRegionLine, hv_x, hv_y, HTuple(hv_Rows[hv_i]), 
                    HTuple(hv_Columns[hv_i]));
                GetRegionPoints(ho_CurRegionLine, &hv_Rows1, &hv_Columns1);
                GetGrayval(ho_BinImage, hv_Rows1, hv_Columns1, &hv_Grayval);
                TupleSum(hv_Grayval, &hv_Sum);
                if (0 != (int(hv_Sum==0)))
                {
                  Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
                }
                else
                {
                  TupleFind(hv_Grayval, 255, &hv_Indices);
                  GenRegionLine(&ho_CurRegionLine, hv_x, hv_y, HTuple(hv_Rows1[HTuple(hv_Indices[0])]), 
                      HTuple(hv_Columns1[HTuple(hv_Indices[0])]));
                  Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
                }
              }
              }
              //RegionUnion1为当前x,y坐标点能扫描到的最大面积
              Intersection(ho_RegionUnion1, ho_RegionErosion, &ho_RegionUnion1);
              AreaCenter(ho_RegionUnion1, &hv_Area1, &hv_Row1, &hv_Column1);
              if (0 != (int(hv_Area1>hv_AreaMax)))
              {
                ErosionRectangle1(ho_ObjectSelected, &ho_RegionErosion1, 20, 20);
                GenRegionPoints(&ho_RegionPoint1, hv_x, hv_y);
                Intersection(ho_RegionPoint1, ho_RegionErosion1, &ho_RegionIntersection1
                    );
                AreaCenter(ho_RegionIntersection1, &hv_Area3, &hv_Row4, &hv_Column4);
                if (0 != (int(hv_Area3>0)))
                {
                  hv_AreaMax = hv_Area1;
                  hv_x_max[hv_station_num] = hv_x;
                  hv_y_max[hv_station_num] = hv_y;
                }

              }
            }
          }
          }
        }
        }

        GenEmptyRegion(&ho_RegionUnion1);
        {
        HTuple end_val149 = (hv_Rows.TupleLength())-1;
        HTuple step_val149 = 1;
        for (hv_i=0; hv_i.Continue(end_val149, step_val149); hv_i += step_val149)
        {
          GenRegionLine(&ho_CurRegionLine, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
              HTuple(hv_Rows[hv_i]), HTuple(hv_Columns[hv_i]));
          GetRegionPoints(ho_CurRegionLine, &hv_Rows1, &hv_Columns1);
          GetGrayval(ho_BinImage, hv_Rows1, hv_Columns1, &hv_Grayval);
          TupleSum(hv_Grayval, &hv_Sum);
          if (0 != (int(hv_Sum==0)))
          {
            Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
          }
          else
          {
            TupleFind(hv_Grayval, 255, &hv_Indices);
            GenRegionLine(&ho_CurRegionLine, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
                HTuple(hv_Rows1[HTuple(hv_Indices[0])]), HTuple(hv_Columns1[HTuple(hv_Indices[0])]));
            Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
          }
        }
        }
        Intersection(ho_RegionUnion1, ho_RegionErosion, &ho_RegionUnion1);

        Difference(ho_RegionErosion, ho_RegionUnion1, &ho_RegionErosion);
        AreaCenter(ho_RegionErosion, &hv_Area2, &hv_Row2, &hv_Column2);

        //************显示***************
        hv_position_row[hv_count] = HTuple(hv_x_max[hv_station_num]);
        hv_position_col[hv_count] = HTuple(hv_y_max[hv_station_num]);
        hv_count += 1;
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Image, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),"green");
        if (HDevWindowStack::IsOpen())
          DispObj(ho_RegionUnion1, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),"red");
        GenCircle(&ho_Circle1, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
            2);
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Circle1, HDevWindowStack::GetActive());

        //stop ()
        //******************************
        hv_station_num += 1;

        if (0 != (int(hv_Area2<5)))
        {
          break;
        }
      }

      //
    }
  }
  }

  //stop ()
  //*************************************************************************************
  //***********************************显示结果**************************************************

  //显示扫描站点
  GenEmptyRegion(&ho_RegionUnion);
  for (hv_i=hv_position_row.TupleLength(); hv_i>=1; hv_i+=-1)
  {
    hv_position_row[hv_i] = HTuple(hv_position_row[hv_i-1]);
    hv_position_col[hv_i] = HTuple(hv_position_col[hv_i-1]);

  }
  //起点坐标
  hv_position_row[0] = 500;
  hv_position_col[0] = 500;
  {
  HTuple end_val205 = (hv_position_row.TupleLength())-1;
  HTuple step_val205 = 1;
  for (hv_i=0; hv_i.Continue(end_val205, step_val205); hv_i += step_val205)
  {
    GenCircle(&ho_Circle, HTuple(hv_position_row[hv_i]), HTuple(hv_position_col[hv_i]), 
        2);
    Union2(ho_Circle, ho_RegionUnion, &ho_RegionUnion);
  }
  }
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"magenta");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionUnion, HDevWindowStack::GetActive());


}

int flag  = 1;  //0表示还未到达目的
void MoveBaseResultsCallback(const move_base_msgs::MoveBaseActionResult::ConstPtr &msg)
{  
  WaitSeconds(1);
  flag = 1; 
}

int main(int argc, char *argv[])
{
  //用于解析ROS参数，第三个参数为本节点名
  ros::init(argc, argv, "nav_inf_pub");

  //实例化句柄，初始化node
  ros::NodeHandle nh;

  float position_row[8]={754,438,632,1242,1710,1070,1686,1432};
  float position_col[8]={1450,1150,417,758,1398,1626,878,422};
  
 // action(position_row, position_col);

  // ROS_INFO("%f %f %f %f %f %f %f %f %f", position_col[0], position_col[1], position_col[2], position_col[3], position_col[4],
  //  position_col[5], position_col[6], position_col[7], position_col[8]);

  

  for(int i = 0; i<8;i++)
  {
      position_row[i] = (position_row[i] - 1000)/50;
      position_col[i] = (position_col[i] - 1000)/50;
  }

  move_base_msgs::MoveBaseActionGoal goal;

  //创建publisher  
  ros::Publisher pub = nh.advertise<move_base_msgs::MoveBaseActionGoal>("/move_base/goal",1);   // 1 表示缓冲队列长度
  ros::Subscriber sub = nh.subscribe("/move_base/result", 1, MoveBaseResultsCallback);

  //定义发布的频率 
  ros::Rate loop_rate(1.0);
  // goal.goal.target_pose.pose.position.x = position_col[0];
  // goal.goal.target_pose.pose.position.y = -position_row[0];
  // goal.goal.target_pose.pose.orientation.x = 0;
  // goal.goal.target_pose.pose.orientation.y = 0;
  // goal.goal.target_pose.pose.orientation.z = 0;
  // goal.goal.target_pose.pose.orientation.w = 1;
  // goal.goal.target_pose.header.frame_id = "map";
  loop_rate.sleep();
  //loop_rate.sleep();

  int i = 0;
  while(ros::ok())
  {
    goal.goal.target_pose.pose.position.x = position_col[i];
    goal.goal.target_pose.pose.position.y = -position_row[i];
    goal.goal.target_pose.pose.orientation.x = 0;
    goal.goal.target_pose.pose.orientation.y = 0;
    goal.goal.target_pose.pose.orientation.z = 0;
    goal.goal.target_pose.pose.orientation.w = 1;
    goal.goal.target_pose.header.frame_id = "map";

    ros::spinOnce();
    if(flag == 1)
    {
      ROS_INFO("Position: x = %f, y = %f ", goal.goal.target_pose.pose.position.x, goal.goal.target_pose.pose.position.y);
      pub.publish(goal);
      i++;
      flag = 0;
    //   if(i == 9)  //当i达到最大值时，退出循环，实际运用时该最大值应从图像程序中获取，这里是做实验，故直接给出了数值
    //   {
    //     break;
    //   }
    }
  }

  return 0;
} 

