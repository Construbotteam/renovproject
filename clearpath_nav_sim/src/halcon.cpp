///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.11.2.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (utf8).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) \
                         && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Local procedures 
void find_door (HTuple hv_cur_region, HTuple hv_door_num, HTuple hv_door_region1, 
    HTuple hv_door_region2, HTuple *hv_next_region, HTuple *hv_door_array, HTuple *hv_next_region_num);

// Procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Local procedures 
void find_door (HTuple hv_cur_region, HTuple hv_door_num, HTuple hv_door_region1, 
    HTuple hv_door_region2, HTuple *hv_next_region, HTuple *hv_door_array, HTuple *hv_next_region_num)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_count, hv_n, hv_last_count, hv_i, hv_cur_count;

  //找到属于当前region的门
  //输入：当前region的编号:cur_region
  //输入：门的数量：door_num
  //输入：门所属的两个region编号：door_region1 and door_region2
  //输出：找到的门的编号，位置，门的另一边所对应的region:next_region
  //输出：经过的门数组,用于存储门的编号:door_array
  //输出：每个输入的cur_region对应产生的next_region数量： next_region_num
  hv_count = 0;
  {
  HTuple end_val8 = (hv_cur_region.TupleLength())-1;
  HTuple step_val8 = 1;
  for (hv_n=0; hv_n.Continue(end_val8, step_val8); hv_n += step_val8)
  {
    //进入该次循环时count计数
    hv_last_count = hv_count;
    {
    HTuple end_val11 = hv_door_num-1;
    HTuple step_val11 = 1;
    for (hv_i=0; hv_i.Continue(end_val11, step_val11); hv_i += step_val11)
    {
      if (0 != (HTuple(int(HTuple(hv_door_region1[hv_i])==HTuple(hv_cur_region[hv_n]))).TupleOr(int(HTuple(hv_door_region2[hv_i])==HTuple(hv_cur_region[hv_n])))))
      {
        if (0 != (int(HTuple(hv_door_region1[hv_i])==HTuple(hv_cur_region[hv_n]))))
        {
          (*hv_next_region)[hv_count] = HTuple(hv_door_region2[hv_i]);
          (*hv_door_array)[hv_count] = hv_i;
          hv_count += 1;
        }
        else
        {
          (*hv_next_region)[hv_count] = HTuple(hv_door_region1[hv_i]);
          (*hv_door_array)[hv_count] = hv_i;
          hv_count += 1;

        }
      }
    }
    }
    //走出该次循环时count计数
    hv_cur_count = hv_count;
    //计算出该次输入对应产生的分支数量
    (*hv_next_region_num)[hv_n] = hv_cur_count-hv_last_count;
  }
  }

  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_ImageChannel2, ho_Regions;
  HObject  ho_RegionObstacle, ho_RegionDilation, ho_RegionClosing;
  HObject  ho_RegionDifference, ho_BinImage, ho_BinImageObstacle;
  HObject  ho_RegionFillUp, ho_ImageReduced, ho_ConnectedRegions;
  HObject  ho_RegionCollection, ho_ObjectSelected, ho_ImageReduced2;
  HObject  ho_InitRegion, ho_Region, ho_RegionErosion, ho_Contours;
  HObject  ho_ContoursRegion, ho_RegionLines, ho_RegionUnion1;
  HObject  ho_Circle1, ho_RegionPoint, ho_RegionIntersection;
  HObject  ho_CurRegionLine, ho_RegionErosion1, ho_RegionPoint1;
  HObject  ho_RegionIntersection1, ho_RegionUnion, ho_Circle;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_Number, hv_count, hv_offset, hv_I, hv_Area, hv_CenterRow;
  HTuple  hv_CenterColumn, hv_Rows, hv_Columns, hv_flag, hv_index;
  HTuple  hv_LineRows, hv_LineColumns, hv_Grayval, hv_Sum;
  HTuple  hv_Length, hv_grayval, hv_position_row, hv_position_col;
  HTuple  hv_station_num, hv_AreaMax, hv_x, hv_y, hv_Row;
  HTuple  hv_Column, hv_i, hv_Rows1, hv_Columns1, hv_Indices;
  HTuple  hv_Area1, hv_Row1, hv_Column1, hv_Area3, hv_Row4;
  HTuple  hv_Column4, hv_x_max, hv_y_max, hv_Area2, hv_Row2;
  HTuple  hv_Column2;

  dev_update_off();
  //Image Acquisition 01: Code generated by Image Acquisition 01
  ReadImage(&ho_Image, //'/home/hao/Documents/shen/halcon_pro/nav_sim/平面图/1.png'
      "/home/hao/Documents/shen/halcon_pro/nav_sim/\345\271\263\351\235\242\345\233\276/1.png");

  //********************************分离出房间*********************************
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width,hv_Height,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  AccessChannel(ho_Image, &ho_ImageChannel2, 2);
  //不带障碍物的region
  Threshold(ho_ImageChannel2, &ho_Regions, 0, 34);
  //带障碍物的region
  Threshold(ho_Image, &ho_RegionObstacle, 0, 80);
  DilationRectangle1(ho_Regions, &ho_RegionDilation, 1, 1);
  ClosingRectangle1(ho_RegionDilation, &ho_RegionClosing, 1, 1);
  //closing_rectangle1 (RegionDilation, RegionClosing, 10, 210)
  //识别出门的位置
  Difference(ho_RegionClosing, ho_RegionDilation, &ho_RegionDifference);
  RegionToBin(ho_RegionClosing, &ho_BinImage, 255, 0, hv_Width, hv_Height);
  //带障碍物的二值图
  RegionToBin(ho_RegionObstacle, &ho_BinImageObstacle, 255, 0, hv_Width, hv_Height);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  ReduceDomain(ho_BinImage, ho_RegionFillUp, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, 0, 80);
  Connection(ho_Regions, &ho_ConnectedRegions);
  //得到房间数量
  CountObj(ho_ConnectedRegions, &hv_Number);
  //stop ()

  //***************************************************************************
  //********************************对分离出的每个房间进行处理*******************************
  //计数
  hv_count = 0;
  hv_offset = 100;
  GenEmptyRegion(&ho_RegionCollection);
  {
  HTuple end_val36 = hv_Number;
  HTuple step_val36 = 1;
  for (hv_I=1; hv_I.Continue(end_val36, step_val36); hv_I += step_val36)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_I);
    ReduceDomain(ho_BinImageObstacle, ho_ObjectSelected, &ho_ImageReduced2);
    //搜索的区域
    Threshold(ho_ImageReduced2, &ho_InitRegion, 0, 80);
    //每次搜索后递减的区域变量
    Threshold(ho_ImageReduced2, &ho_Region, 0, 80);
    //确保产生的边缘region在BinImage内部
    ErosionRectangle1(ho_Region, &ho_RegionErosion, 3, 3);
    GenContourRegionXld(ho_RegionErosion, &ho_Contours, "border");
    GenRegionContourXld(ho_Contours, &ho_ContoursRegion, "margin");
    //dilation_rectangle1 (ContoursRegion, RegionDilation, 1, 1)
    //搜索的区域
    //fill_up (ContoursRegion, InitRegion)
    //每次搜索后递减的区域变量
    //fill_up (ContoursRegion, Region)

    AreaCenter(ho_Region, &hv_Area, &hv_CenterRow, &hv_CenterColumn);
    RegionToBin(ho_Region, &ho_BinImage, 0, 255, hv_Width, hv_Height);
    GetRegionPoints(ho_ContoursRegion, &hv_Rows, &hv_Columns);

    //0表示全都能扫到
    hv_flag = 0;
    {
    HTuple end_val59 = (hv_Rows.TupleLength())-1;
    HTuple step_val59 = 1;
    for (hv_index=0; hv_index.Continue(end_val59, step_val59); hv_index += step_val59)
    {
      GenRegionLine(&ho_RegionLines, HTuple(hv_Rows[hv_index]), HTuple(hv_Columns[hv_index]), 
          hv_CenterRow, hv_CenterColumn);
      GetRegionPoints(ho_RegionLines, &hv_LineRows, &hv_LineColumns);
      GetGrayval(ho_BinImage, hv_LineRows, hv_LineColumns, &hv_Grayval);
      TupleSum(hv_Grayval, &hv_Sum);
      if (0 != (int(hv_Sum>0)))
      {
        //1表示有地方扫不到
        hv_flag = 1;
        //显示扫不到的地方
        TupleLength(hv_LineRows, &hv_Length);
        hv_grayval = HTuple(hv_Length,128);
        //set_grayval (Image, LineRows, LineColumns, grayval)
      }
      //dev_display (BinImage)
      //dev_display (RegionLines)
      //stop ()
    }
    }
    //stop ()
    //如果直接给质心可以扫描完全，则结束算法
    if (0 != (int(hv_flag==0)))
    {
      hv_position_row[hv_count] = hv_CenterRow;
      hv_position_col[hv_count] = hv_CenterColumn;
      hv_count += 1;
      //************显示***************
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //dev_set_color ('green')
      //dev_display (RegionUnion1)
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      GenCircle(&ho_Circle1, hv_CenterRow, hv_CenterColumn, 2);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Circle1, HDevWindowStack::GetActive());
      //stop ()
      //******************************
      //如果直接给质心无法扫描完全，则执行后面的方案（贪婪）
    }
    else
    {

      hv_station_num = 0;
      while (0 != 1)
      {

        GenContourRegionXld(ho_RegionErosion, &ho_Contours, "border");
        GenRegionContourXld(ho_Contours, &ho_ContoursRegion, "margin");
        Union1(ho_ContoursRegion, &ho_ContoursRegion);
        //dilation_rectangle1 (ContoursRegion, RegionDilation, 1, 1)
        //fill_up (ContoursRegion, RegionFillUp)
        //erosion_rectangle1 (RegionFillUp, RegionFillUp, 4, 4)
        //reduce_domain (BinImageObstacle, Region, ImageReduced1)
        //threshold (ImageReduced1, Region, 0, 80)
        RegionToBin(ho_Region, &ho_BinImage, 0, 255, hv_Width, hv_Height);
        GetRegionPoints(ho_ContoursRegion, &hv_Rows, &hv_Columns);

        hv_AreaMax = 0;
        {
        HTuple end_val109 = hv_Height;
        HTuple step_val109 = 28;
        for (hv_x=0; hv_x.Continue(end_val109, step_val109); hv_x += step_val109)
        {
          {
          HTuple end_val110 = hv_Width;
          HTuple step_val110 = 28;
          for (hv_y=0; hv_y.Continue(end_val110, step_val110); hv_y += step_val110)
          {
            GenRegionPoints(&ho_RegionPoint, hv_x, hv_y);
            Intersection(ho_RegionPoint, ho_InitRegion, &ho_RegionIntersection);
            AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Column);
            if (0 != (int(hv_Area>0)))
            {
              GenEmptyRegion(&ho_RegionUnion1);
              {
              HTuple end_val116 = (hv_Rows.TupleLength())-1;
              HTuple step_val116 = 1;
              for (hv_i=0; hv_i.Continue(end_val116, step_val116); hv_i += step_val116)
              {
                GenRegionLine(&ho_CurRegionLine, hv_x, hv_y, HTuple(hv_Rows[hv_i]), 
                    HTuple(hv_Columns[hv_i]));
                GetRegionPoints(ho_CurRegionLine, &hv_Rows1, &hv_Columns1);
                GetGrayval(ho_BinImage, hv_Rows1, hv_Columns1, &hv_Grayval);
                TupleSum(hv_Grayval, &hv_Sum);
                if (0 != (int(hv_Sum==0)))
                {
                  Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
                }
                else
                {
                  TupleFind(hv_Grayval, 255, &hv_Indices);
                  GenRegionLine(&ho_CurRegionLine, hv_x, hv_y, HTuple(hv_Rows1[HTuple(hv_Indices[0])]), 
                      HTuple(hv_Columns1[HTuple(hv_Indices[0])]));
                  Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
                }
              }
              }
              //RegionUnion1为当前x,y坐标点能扫描到的最大面积
              Intersection(ho_RegionUnion1, ho_RegionErosion, &ho_RegionUnion1);
              AreaCenter(ho_RegionUnion1, &hv_Area1, &hv_Row1, &hv_Column1);
              if (0 != (int(hv_Area1>hv_AreaMax)))
              {
                ErosionRectangle1(ho_ObjectSelected, &ho_RegionErosion1, 60, 60);
                GenRegionPoints(&ho_RegionPoint1, hv_x, hv_y);
                Intersection(ho_RegionPoint1, ho_RegionErosion1, &ho_RegionIntersection1
                    );
                AreaCenter(ho_RegionIntersection1, &hv_Area3, &hv_Row4, &hv_Column4);
                if (0 != (int(hv_Area3>0)))
                {
                  hv_AreaMax = hv_Area1;
                  hv_x_max[hv_station_num] = hv_x;
                  hv_y_max[hv_station_num] = hv_y;
                }

              }
            }
          }
          }
        }
        }

        GenEmptyRegion(&ho_RegionUnion1);
        {
        HTuple end_val149 = (hv_Rows.TupleLength())-1;
        HTuple step_val149 = 1;
        for (hv_i=0; hv_i.Continue(end_val149, step_val149); hv_i += step_val149)
        {
          GenRegionLine(&ho_CurRegionLine, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
              HTuple(hv_Rows[hv_i]), HTuple(hv_Columns[hv_i]));
          GetRegionPoints(ho_CurRegionLine, &hv_Rows1, &hv_Columns1);
          GetGrayval(ho_BinImage, hv_Rows1, hv_Columns1, &hv_Grayval);
          TupleSum(hv_Grayval, &hv_Sum);
          if (0 != (int(hv_Sum==0)))
          {
            Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
          }
          else
          {
            TupleFind(hv_Grayval, 255, &hv_Indices);
            GenRegionLine(&ho_CurRegionLine, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
                HTuple(hv_Rows1[HTuple(hv_Indices[0])]), HTuple(hv_Columns1[HTuple(hv_Indices[0])]));
            Union2(ho_RegionUnion1, ho_CurRegionLine, &ho_RegionUnion1);
          }
        }
        }
        Intersection(ho_RegionUnion1, ho_RegionErosion, &ho_RegionUnion1);

        Difference(ho_RegionErosion, ho_RegionUnion1, &ho_RegionErosion);
        AreaCenter(ho_RegionErosion, &hv_Area2, &hv_Row2, &hv_Column2);

        //************显示***************
        hv_position_row[hv_count] = HTuple(hv_x_max[hv_station_num]);
        hv_position_col[hv_count] = HTuple(hv_y_max[hv_station_num]);
        hv_count += 1;
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Image, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),"green");
        if (HDevWindowStack::IsOpen())
          DispObj(ho_RegionUnion1, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),"red");
        GenCircle(&ho_Circle1, HTuple(hv_x_max[hv_station_num]), HTuple(hv_y_max[hv_station_num]), 
            2);
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Circle1, HDevWindowStack::GetActive());

        //stop ()
        //******************************
        hv_station_num += 1;

        if (0 != (int(hv_Area2<5)))
        {
          break;
        }
      }

      //
    }
  }
  }

  //stop ()
  //*************************************************************************************
  //***********************************显示结果**************************************************

  //显示扫描站点
  GenEmptyRegion(&ho_RegionUnion);
  for (hv_i=hv_position_row.TupleLength(); hv_i>=1; hv_i+=-1)
  {
    hv_position_row[hv_i] = HTuple(hv_position_row[hv_i-1]);
    hv_position_col[hv_i] = HTuple(hv_position_col[hv_i-1]);

  }
  //起点坐标
  hv_position_row[0] = 500;
  hv_position_col[0] = 500;
  {
  HTuple end_val205 = (hv_position_row.TupleLength())-1;
  HTuple step_val205 = 1;
  for (hv_i=0; hv_i.Continue(end_val205, step_val205); hv_i += step_val205)
  {
    GenCircle(&ho_Circle, HTuple(hv_position_row[hv_i]), HTuple(hv_position_col[hv_i]), 
        2);
    Union2(ho_Circle, ho_RegionUnion, &ho_RegionUnion);
  }
  }
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"magenta");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionUnion, HDevWindowStack::GetActive());
  //wait_seconds (420)
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
    XInitThreads();
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif

